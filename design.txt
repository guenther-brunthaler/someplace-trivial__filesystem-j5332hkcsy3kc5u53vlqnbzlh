A trivial filesystem for access by boot scripts
-----------------------------------------------

This document shall document the on-disk design of a trivial file system, which can be read and written in-place by boot scripts without any need (or means) of mounting it.

This filesystem shall typically reside in a raw partiton of type "non-fs data", but shall contain a (completely unused) kernel-supported filesystem for the mere purpose of providing a volume label and UUID.

The filesystem is generated by a script, and can only be read or written in-place after it has been created.

The file system starts with a UNIX-format text (ASCII LF terminates every line) metadata area of the following format:

TrivialFS=80a29844-f5e3-11e3-b1c1-b827eb896db5
UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
<start1>,<size1>=<name1_1>
|<name1_2>
|<name1_3>
<start2>,<size2>=<name2_1>
|<name2_2>
|<name2_3>
...
EOF

Whitespace or empty lines are not allowed in the metadata area, except that whitespace (but no newline character) is allowed in file names.

The first two lines and their order is mandatory.

The first line is used to identify the trivial file system as such. It could be used to identify an image file containing a trivial file system by the "file" utility.

The second line identifies the target UUID when scanning for a particular instance of the trival file system with a given UUID. It must be specified in lower case with the dashes as shown above. Use "uuidgen" to generate appropriately formatted UUIDs.

The remaining lines describe comments or directory entries, and metadata area stops once a line has been read which does not follow the syntax for a directory entry or comment.

By convention, that line will contain the text "EOF", but this is not actually required. Any line not conforming to a valid directory entry syntax terminates the metadata area.

After this area, the file contents area starts.

A comment is any line starting with a "#" and will be ignored. Note that comments are not allowed in the first two lines.

File contents are described by "<start>,<size>,<mode>,<mtime>=<first_name>" which are unsigned decimal integer starting offset and size. Both have byte granularity. The starting offset is relative to the first byte of the file system.

The octal file <mode> and the decimal <mtime> are only included to allow trivialfs_explode to restore the original date and file mode. Further file attributes like ownership or extended attributes are not recorded at all.

Within the newly created file system, the <mtime> will not be updated by write accesses; so it is actually only the mtime at the time of filesystem creation.

After every line describing file contents, any number of continuation lines may follow which contain "|<another_name>" in order to specify alternative names for the same file (i. e. hard links).

The starting offset is not really relevant for files of size zero, but by convention all such files shall use a starting offset of zero, even though this is not actually part of the file contents area.

There is no requirement to use all available space or regarding the order of file contents; however the contents of each file must be contiguous.

The minimum size possible for a filesystem is 90 Bytes, which contains the mandatory header files and an empty line to terminate the metadata area.

The scan for a file name starts at the beginning of the metadata area; the first matching file will be found.

File names can have any size including the empty string, and they can contain any character except newline.

There is no direct support for subdirectories, but it can be emulated by including "/" as part of the filenames which serves no special purpose in TrivialFS. For example, instead of a subdirector d with two files a and b within it, two filenames d/a and d/b could be used with a similar effect. There is no way to "cd" into a subdirectory, though. The file system generation script will in fact use this approach if subdirectories are present in the input directory.

The metadata area is not designed to be modified after filesystem creation.

All file modifications should therefore be made in-place within the offset and size specified in the directory entry.

If some file's contents have variable size when being updated, the file itself should have been created with the largest possible initial size, and the file contents themselves should be defined in a way to discover the actually used part of the file contents. For instance, the file contents might be prefixed by its payload length and a separator beforr the payload starts.

There are four scripts:

* trivialfs_gen generates a new trivial file system recursively from the contents of the current directory. Symbolic links will automatically be transformed into hard links within the generated file system. The generated file system will either be written to the file or block device given as the only argument, or to standard output if invoked without arguments.

* trivialfs_volume accepts a UUID as argument and scans for a block device containing a TrivialFS with a matching "UUID="-line. Option -l includes loop devices, and -n includes NBD devices. Alternatively, a list of files can be specified as additional arguments after the UUID on the command line. In this case, those files are treated as file system image files and are examined in the same order. If successful, the path to the first image file or block device containing the requested UUID is written to standard output.

* trivialfs_file accepts an optional volume pathname as returned by trivialfs_volume and a file name as arguments, and (if successful only) writes the start index, byte size and volume pathname as a single line to standard output, separated by a single ASCII SPACE. If only a single argument is provided, it reads the volume path name from standard input.

* trivialfs_read expects the output of trivialfs_file as standard input, and writes the contents of the described file from the trivial file system to standard output.

* trivialfs_write has the same arguments as trivialfs_read, but accepts up to as many bytes from standard input as the file contents allows, and overwrites the beginning of the described file contents with that.

* trivialfs_explode is the opposite of trivialfs_gen and populates the contents of the current directory with the contents of a TrivialFS, a path to which can be specified either as the only argument or will be read from standard input.
