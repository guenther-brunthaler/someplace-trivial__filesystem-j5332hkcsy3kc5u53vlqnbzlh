A trivial filesystem for access by boot scripts
-----------------------------------------------

This document shall document the on-disk design of a trivial file system, which can be read and written in-place by boot scripts without any need (or means) of mounting it.

This filesystem shall typically reside in a raw partiton of type "non-fs data", but shall contain a (completely unused) kernel-supported filesystem for the mere purpose of providing a volume label and UUID.

The filesystem is generated by a script, and can only be read or written in-place after it has been created.

The file system starts with a UNIX-format text (ASCII LF terminates every line) metadata area of the following format:

TrivialFS=80a29844-f5e3-11e3-b1c1-b827eb896db5
COMPATIBLE_VERSION=3
UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
LABEL=volume label
ACTUAL_VERSION=3
CREATED=<unixtime>
@<offset1>+<size1>=<pathname1>
@<offset2>+<size2>=<pathname2>
...
END

Whitespace or empty lines are not allowed in the metadata area, except that whitespace (but no newline character) is allowed in file and volume label names.

The first line is fixed. It is used to identify the trivial file system as such. It could be used to identify an image file containing a trivial file system by the "file" utility. The UUID in that line is part of the signature and will never change. It is not to be confused with the "UUID="-line which represents the UUID of the filesystem instance.

The second line defines the version number of the metadata format which the reader must understand in order to parse the metadata successfully. It is a simple integer without leading zeros. The version number in the example above specifies the value implementers of THIS version of the specification must write when creating a compliant filesystem.

In the third line, a line defining the filesystem instance UUID must be present. This shall be a valid DCE UUID, such as generated by "uuidgen". The UUID can be specified directly by the -u option or indirectly via the -r or -t options when the filesystem is generated. Different revisions of the same filesystem should always use the same UUID, as this will typically be used to locate the filesystem. The UUID must use dashes as shown for formatting, and must only use lower-case characters for representing hexadecimal digits "a" through "f". This is important, because the scripts will typically compare the UUID using a simple case-significant string comparison which does not care about a possible normalized binary representation of the UUIDs to be compared.

In the fourth line, the volume label for the filesystem must be specified. The entry must be present although it may be empty. The label can have any size and contain any character except newline. The letter case is significant for searches.

Following the fourth line, an arbitrary number of additional KEY=VALUE lines may follow, which specify further attributes for the whole file system rather than for particular files. The order does not matter and may not be preserved by tools which rewrite the metadata. Unrecognized KEYs will be silently ignored by compliant readers. Letter case is significant in KEY names; therefore "Name" and "name" represent two different keys.

Any string not containing a newline character, "=" or starting with a "@" is eligible as a KEY, and the following KEYs have been defined so far:

* ACTUAL_VERSION defines the current version number of THIS specification. It is a simple integer without leading zeros. It must be the same as COMPATIBLE_VERSION or can be higher if the current version is fully backwards-compatible to COMPATIBLE_VERSION. Readers might enable optional features and support additional KEYs if they understand the current version specified by this KEY. This KEY is optional. If it is missing, ACTUAL_VERSION will be assumed to be the same as COMPATIBLE_VERSION.

* CREATED defines the UNIX timestamp of the filesystem creation using UTC as time zone. It is optional, purely informational and not used for anything.

Additional entries may be defined in future revisions of the file format.

The remaining lines describe only directory entries (which all start with "@"), and the whole metadata area stops once a line has been read which does not follow the syntax for a directory entry.

By convention, that line will contain the text "END", but this is not actually required. Any line not conforming to a valid directory entry syntax terminates the metadata area.

After this area, the file contents area starts.

File contents are described by directory entries in the metadata area. Every directory entry has the format

@<offset>+<size>=<pathname>

where <offset> is the 0-based starting offset into the volume, and <size> is the size of the file's contents. 0-sized files are allowed and could be used, for example, as tag files.

<offset> and <size> are both measured in bytes and must be specified as a decimal number without unnecessary leading zeros.

<offset> is also used as the "inode" for a file and must therefore be unique, unless files are "hard-linked".

The <offset> uniqueness of non-hardlinked files must even be assured for zero-sized files, even though <offset> is otherwise irrelevant for them. It it therefore not a requirement that <offset> refers to a valid offset after the metadata area as it is the case for normal files; <offset> could point into the metadata area as well.

In particular, it might be a good idea (but this is no requirement at all) to use increasing integers 1, 2 etc. as <offset> for zero-sized files. This can never be mismatched with real <offset> offsets of actual file contents, because there can never be more zero-sized files than there are directory entries, and every directory entry is larger than one byte.

<pathname> specifies the path name of the file within the filesystem. Path components are separated (not prefixed or terminated) from each other by "/" as usual.

Path name components must not be empty; at least not at the application level. Internally, a TrivialFS-Implementation might choose to use path names containing zero-sized components for internal metadata files. Such path names must never be used by application code, though, and will be hidden from any TrivialFS tools which might provide directory listings.

Therefore, there is no "/" at the beginning of a regular TrivialFS <pathname>: "/name" as a <pathname> would mean "name" is not an entry of the top-level directory, but rather a member of a top-level directory "" (i. e. a top-level directory with an empty string as its name), which is forbidden. "name" alone on the other hand means an entry "name" in the top-level directory, and "dir/name" means an entry "name" in the top-level directory "dir".

TrivialFS supports hard links by simply using the same <offset> and <size> for different path names. There is no requirement that the metadata entries for such hard-linked files have to be adjacent or need to occur in any particular order.

Symbolic links are not directly supported, but the filesystem generator script will typically convert symlinks into hardlinks when creating the file system, so they will at least appear to work as well.

There is no special requirement how to sort directory entries within the metadata area.

There is no requirement to use all available space or regarding the relative order of file contents within the volume; however the contents of each file must be contiguous.

Gaps of unallocated space between the contents of files or between the metadata area and the first file content area are allowed. This might be useful for alignment purposes, or as buffer space for creating new files in a future implementation (the current one only supports in-place writes for already-existing files).

An implementation might also use parts of those "unallocated" areas for its own internal purposes, as long as it does not change the way the metadata has to be interpreted by an in-place reader or -writer.

Future versions of TrivialFS might even add completely dynamic writing to and resizing of existing files by implementing various garbage collection and buffer area allocation schemes. However, the eventual files must never become fragmented as a consequence of this: At any consistent state, all files in TrivalFS must consist of a single, adjacent offset range. That is, file contents might move around (by updating <offset> in the metadata area accordingly), but they must never become fragmented.

There is no alignment requirement dictated by this specification; byte alignment of all structures is therefore possible. Of course, an implementation is also free to align <offset> offsets in any way deemed advantageous. Alignment does not change the way the TrivialFS metadata has to be parsed.

The minimum size possible for a filesystem is 118 Bytes, which contains the mandatory header lines and an empty line (instead of the conventional "END") to terminate the metadata area.

The scan for a file name starts at the beginning of the metadata area; the first matching file will be returned as found.

Directories are only represented indirectly by using path names which include directory components; it is therefore not possible to represent empty directories. (However, "hidden" empty files such as ".keep" may be put into a directory, causing it to exist.)

Path names can have any size although implementation may restrict the maximum supported size. Conforming implementations MUST at least support path names up to a length of 256 bytes. Path names MAY contain any character except newline (ASCII 'NL' with code point 0x0a), but conforming implementations SHOULD reject byte values less than code point 0x20. Especially codepoint 0 SHOULD be avoided in names.

Path names SHOULD be UTF-8 encoded, but there is no actual encoding requirement. For instance, UTF-16 might be a more efficient encoding for CJK-like languages. TrivialFS implementation should consider path names as byte strings, and not care about their contents other than comparing them and assuming that the first byte with value 0x0a terminates the name.

The metadata area is not designed to be modified after filesystem creation (although nothing will stop an implementation from doing so).

All file modifications should therefore be made in-place within the offset and size specified in the directory entry.

If some file's contents have variable size when being updated, the file itself should have been created with the largest possible initial size, and the file contents themselves should be defined in a way to discover the actually used part of the file contents. For instance, the file contents might be prefixed by its payload length and a separator (such as newline) before the payload starts. Or the file contents may be prematurely terminated by some "EOF" character (such as Ctrl-D) defined by the application using the file.

Metadata and file reads SHOULD be protected by a shared lock, any write operation SHOULD be protected by an exclusive lock. flock-based file locks SHOULD be used rather than fcntl-based record locks, because it is directly supported by the "flock" command-line utility. Locks should only be held as short as possible.

Readers MAY assume that metadata for a particular file will never change once it has been read since locating the filesystem after the system has been started.
