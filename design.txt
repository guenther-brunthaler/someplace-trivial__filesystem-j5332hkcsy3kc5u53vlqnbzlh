A trivial filesystem for access by boot scripts
-----------------------------------------------

This document shall document the on-disk design of a trivial file system, which can be read and written in-place by boot scripts without any need (or means) of mounting it.

This filesystem shall typically reside in a raw partiton of type "non-fs data", but shall contain a (completely unused) kernel-supported filesystem for the mere purpose of providing a volume label and UUID.

The filesystem is generated by a script, and can only be read or written in-place after it has been created.

The file system starts with a UNIX-format text (ASCII LF terminates every line) metadata area of the following format:

TrivialFS=80a29844-f5e3-11e3-b1c1-b827eb896db5
COMPATIBLE_VERSION=3
UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
LABEL=volume label
ACTUAL_VERSION=3
CREATED=<unixtime>
@<start1>+<size1>=<pathname1>
@<start2>+<size2>=<pathname2>
...
EOF

Whitespace or empty lines are not allowed in the metadata area, except that whitespace (but no newline character) is allowed in file and volume label names.

The first line is mandatory. It is used to identify the trivial file system as such. It could be used to identify an image file containing a trivial file system by the "file" utility. The UUID in that line is part of the signature and will never change. It is not to be confused with the "UUID="-line which represents the UUID of the filesystem instance.

The second line defines the version number of the metadata format which the reader must understand in order to parse the metadata successfully. It is a simple integer without leading zeros. The version number in the example above specifies the value implementers of THIS version of the specification must write when creating a compliant filesystem.

In the third line, a line defining the filesystem instance UUID must be present. The UUID can be specified directly by the -u option or indirectly via the -r or -t options when the filesystem is generated. Different revisions of the same filesystem should always use the same UUID, as this will typically be used to locate the filesystem. The UUID must use dashes as shown for formatting, and must only use lower-case characters for representing hexadecimal digits "a" through "f". This is important, because the scripts will typically compare the UUID using a case-significant string comparison.

In the fourth line, the volume label for the filesystem must be specified. It must be present although it may be empty. The label can have any size and contain any character except newline. The letter case is significant for searches.

Following the fourth line, an arbitrary number of additional KEY=VALUE lines may follow, which specify further attributes for the whole file system rather than for particular files. The order does not matter and duplicate entries are not allowed. Unrecognized KEYs will be silently ignored by compliant readers. Letter case is significant in KEY names; therefore "Name" and "name" represent two different keys.

Any string not containing "=" or starting with a "@" is eligible as a KEY, and the following KEYs have been defined so far:

* ACTUAL_VERSION defines the current version number of THIS specification. It is a simple integer without leading zeros. It must be the same as COMPATIBLE_VERSION or can be higher if the current version is fully backwards-compatible to COMPATIBLE_VERSION. Readers might enable optional features and support additional KEYs if they understand the current version specified by this KEY. This KEY is optional. If it is missing, ACTUAL_VERSION will be assumed to be the same as COMPATIBLE_VERSION.

* CREATED defines the UNIX timestamp of the filesystem creation using UTC as time zone. It is optional, purely informational and not used for anything.

Additional entries may be defined in future revisions of the file format.

The remaining lines describe directory entries, and the whole metadata area stops once a line has been read which does not follow the syntax for a directory entry.

By convention, that line will contain the text "EOF", but this is not actually required. Any line not conforming to a valid directory entry syntax terminates the metadata area.

After this area, the file contents area starts.

File contents are described by directory entries in the metadata area. Every directory entry has the format

@<start>+<size>=<pathname>

where <start> is the 0-based starting offset into the volume, and <size> is the size of the file's contents. 0-sized files are allowed and could be used, for example, as tag files.

<start> and <size> are both measured in bytes and must be specified as a decimal number without unnecessary leading zeros.

<start> is used as the "inode" for a file and must therefore be unique, unless files are "hard-linked".

For this reason, even zero-sized files must occupy at least one byte of space. As an optimization, it is allowed to take offsets for this from the metadata area itself, starting at offset 1. There is no danger in that because zero-sized files have no actual contents which could be read from or written to.

If more zero-sized files are required than the size of the metadata area can represent, actual bytes within the file storage area have to be allocated for serving as further unique <start> values for zero-sized files.

<pathname> specifies the path name of the file within the filesystem. Path components are separated (not prefixed or terminated) from each other by "/" as usual.

There is normally no "/" at the beginning of <pathname> even though this is allowed: "/name" as a <pathname> means "name" is not an entry of the top-level directory, but rather a member of a top-level directory "" (i. e. a top-level directory with an empty string as its name). "name" alone on the other hand means an entry "name" in the top-level directory, and "dir/name" means an entry "name" in the top-level directory "dir".

TrivialFS supports hard links by simply using the same <start> and <size> for different path names.

Symbolic links are not directly supported, but the filesystem generator script will typically convert symlinks into hardlinks when creating the file system, so they will at least appear to work as well.

There is no special requirement how to sort directory entries within the metadata area, although it is recommended to sort them by ascending <start> values.

There is no requirement to use all available space or regarding the order of file contents; however the contents of each file must be contiguous.

The minimum size possible for a filesystem is 118 Bytes, which contains the mandatory header lines and an empty line (instead of "END") to terminate the metadata area.

The scan for a file name starts at the beginning of the metadata area; the first matching file will be returned as found.

Directories are only represented indirectly by using path names which include directory components; it is therefore not possible to represent empty directories. (However, "hidden" empty files such as ".keep" may be put into a directory, causing it to exist.)

Path names can have any size including the empty string, and they can contain any character except newline.

The metadata area is not designed to be modified after filesystem creation.

All file modifications should therefore be made in-place within the offset and size specified in the directory entry.

If some file's contents have variable size when being updated, the file itself should have been created with the largest possible initial size, and the file contents themselves should be defined in a way to discover the actually used part of the file contents. For instance, the file contents might be prefixed by its payload length and a separator before the payload starts. Or the file contents may be prematurely terminated by some "EOF" character (such as Ctrl-D) defined by the application using the file.

There are several scripts:

* trivialfs_gen

* trivialfs_volume

* trivialfs_file

* trivialfs_read

* trivialfs_write

* trivialfs_explode

trivialfs_gen generates a TrivialFS image (or writes it directly to a block device) from the contents of an existing normal directory (including subdirectories; recursive scan).

It converts any symbolic links into hard links; symlinked directories are included multiple times (however, the files within the repeated directories will be hard-linked).

trivialfs_volume finds a TrivialFS volume specified by UUID or volume label, and returns information required by trivialfs_file for locating the correct device.

trivialfs_file takes the information obtained by trivialfs_volume and a pathname within the volume. It scans the directory entries of the volume's metadata area and returns information about the location and size of the file contents within the volume.

* trivialfs_read takes the information returned by trivialfs_file, and returns the whole contents of the file, or, optionally, only a part of it (specified by starting offset into the file and a length in bytes).

* trivialfs_write is similar to trivialfs_read but overwrites parts of all of the file's contents rather than reading it. It cannot be used to extend the file beyond the size recorded in the file's directory entry.

* trivialfs_explode is the opposite of trivialfs_gen and populates the contents of the current directory with the contents of a TrivialFS, a path to which can be specified either as the only argument or will be read from standard input.
