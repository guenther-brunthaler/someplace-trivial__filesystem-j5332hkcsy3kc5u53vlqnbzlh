A trivial filesystem for access by boot scripts
-----------------------------------------------

This document shall document the on-disk design of a trivial file system, which can be read and written in-place by boot scripts without any need (or means) of mounting it.

This filesystem shall typically reside in a raw partiton of type "non-fs data", but shall contain a (completely unused) kernel-supported filesystem for the mere purpose of providing a volume label and UUID.

The filesystem is generated by a script, and can only be read or written in-place after it has been created.

The file system starts with a UNIX-format text metadata area of the following format:

TrivialFS=80a29844-f5e3-11e3-b1c1-b827eb896db5
UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
<start>,<size>=<name1>|<name2>|...
...
<start>,<size>=<name1>|<name2>|...
EOF

Whitespace of empty lines is not allowed in the metadata area, except that whitespace (but no newline character) is allowed in file names.

The first two lines and their order is mandatory.

The first line is used to identify the file system as such.

The second line identifies the UUID to be located when scanning for it. It must be specified in lower case with the dashes as shown above. Use "uuidgen" to generate an appropriately formatted UUID.

The remaining lines describe directory entries, and metadata area stops once a line has been read which does not follow the syntax for a directory entry.

By convention, that line will contain the text "EOF", but this is not actually required. Any line not conforming to a valid directory entry syntax terminates the metadata area.

After this area, the file contents area starts.

File contents are described by <start>,<size> which are unsigned integer starting index and size with byte granularity.

There is no requirement to use all available space or regarding the order of file contents; however the contents of each file must be contiguous.

The minimum size possible for a filesystem is 90 Bytes, which contains the mandatory header files and an empty line to terminate the metadata area.

The scan for a file name starts at the beginning of the metadata area; the first matching file will be found.

File names can have any size including the empty string, and they can contain any characters (including "=") except "|" (the pipe character) and newline.

However, implementation restrictions in the scripts suggest only ASCII characters should be used, whitespace other than ASCII SPACE should be avoided.

Quoting characters like backslashes or quotes should also be avoided for the same reason.

There is no direct support for subdirectories, but it can be emulated by including "/" as part of the filenames which serve no special purpose in TrivialFS. For example, instead of a subdirector d with two files a and b within it, two filenames d/a and d/b could be used with a similar effect. There is no way to "cd" into a subdirectory, though. The file system generation script will in fact use this approach if subdirectories are present in the input directory.

The metadata area is not designed to be modified after filesystem creation.

All file modifications should therefore be made in-place within the offset and size specified in the directory entry.

If some file's contents have variable size when being updated, the file itself should have been created with the largest possible initial size, and the file contents themselves should be defined in a way to discover the actually used part of the file contents. For instance, the file contents might be prefixed by its payload length and a separator bevor the payload starts.

There are four scripts:

* trivialfs_gen generates the file system from a directory with files. Symbolic links will automatically be transformed into hard links within the generated file system.

* trivialfs_volume accepts a UUID as argument and scans for a block device containing a TrivialFS with a matching "UUID="-line.

* trivialfs_file accepts an optional volume pathname as returned by trivialfs_volume and a file name as arguments, and returns the start index and the byte size if its contents if the file was found. Otherwise, it returns an empty line. If only a single argument is provided, it reads the volume path name from standard input.

* trivialfs_read accepts an offset and size as optional arguments, or reads a line containing both (as written by trivialfs_file) from standard input, and writes the contents of the file to standard output.

* trivialfs_write has the same arguments as trivialfs_write, but accepts up to as many bytes from standard input as the file contents allows, and overwrites the beginning of the file contents with that.

