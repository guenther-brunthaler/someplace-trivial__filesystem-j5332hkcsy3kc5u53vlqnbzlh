A trivial filesystem for access by boot scripts
-----------------------------------------------

This document shall document the on-disk design of a trivial file system, which can be read and written in-place by boot scripts without any need (or means) of mounting it.

This filesystem shall typically reside in a raw partiton of type "non-fs data", but shall contain a (completely unused) kernel-supported filesystem for the mere purpose of providing a volume label and UUID.

The filesystem is generated by a script, and can only be read or written in-place after it has been created.

The file system starts with a UNIX-format text (ASCII LF terminates every line) metadata area of the following format:

TrivialFS=80a29844-f5e3-11e3-b1c1-b827eb896db5
COMPATIBLE_VERSION=1
UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
LABEL=volume label
ACTUAL_VERSION=2
CREATED=<unixtime>
<start1>,<size1>=<name1_1>
|<name1_2>
|<name1_3>
<start2>,<size2>=<name2_1>
|<name2_2>
|<name2_3>
...
EOF

Whitespace or empty lines are not allowed in the metadata area, except that whitespace (but no newline character) is allowed in file and volume label names.

The first line is mandatory. It is used to identify the trivial file system as such. It could be used to identify an image file containing a trivial file system by the "file" utility.

The second line defines the version number of the metadata format which the reader must understand in order to parse the metadata successfully. It is a simple integer without leading zeros. The version number in the example above specifies the value implementers of THIS version of the specification must write when creating a compliant filesystem.

In the third line, a line defining the filesystem UUID must be present. The UUID can be specified directly by the -u option or indirectly via the -r or -t options when the filesystem is generated.

In the fourth line, the volume label for the filesystem must be specified. It must be present although it may be empty. The label can have any size and contain any character except newline.

Following the fourth line, an arbitrary number of additional KEY=VALUE lines may follow, which specify further attributes for the whole file system rather than for particular files. The order does not matter and duplicate entries are not allowed. Unrecognized KEYs will be silently ignored by compliant readers.

Any string not containing "=" is eligible as a KEY, and the following KEYs have been defined so far:

* ACTUAL_VERSION defines the current version number of THIS specification. It is a simple integer without leading zeros. It must be the same as COMPATIBLE_VERSION or can be higher if the current version is fully backwards-compatible to COMPATIBLE_VERSION. Readers might enable optional features and support additional KEYs if they understand the current version specified by this KEY. This KEY is optional. If it is missing, ACTUAL_VERSION will be assumed to be the same as COMPATIBLE_VERSION.

* CREATED defines the UNIX timestamp of the filesystem creation using UTC as time zone. It is optional, purely informational and not used for anything.

Additional entries may be defined in future revisions of the file format

The remaining lines describe directory entries, and metadata area stops once a line has been read which does not follow the syntax for a directory entry.

By convention, that line will contain the text "EOF", but this is not actually required. Any line not conforming to a valid directory entry syntax terminates the metadata area.

After this area, the file contents area starts.

File contents are described by "@<start>+<size>,M=<mode>,T=<mtime>,P=<first_name>" which are unsigned decimal integer starting offset and size. Both have byte granularity. The starting offset is relative to the first byte of the file system.

The octal file <mode> and the decimal UNIX-timestamp <mtime> are only included to allow trivialfs_explode to restore the original date and file mode. Further file attributes like ownership or extended attributes are not recorded at all.

Within the newly created file system, the <mtime> will not be updated by write accesses; so it is actually only the mtime at the time of filesystem creation.

Additional key/value attribute pairs may be added and will be ignored my a reader which does not understand them. Key names must not necessarily be one character long, but should be as short as possible without being ambiguous in order to save space. Comparison is case-sensitive. Only alphanumerics plus underscore are allowed in key names. Keys must be unique and the order of pairs is arbitrary, except for the "P"-attribute must always be the last attribute in the line. "@start+size" must always precede all key/value pairs in the entry line. 

After every line describing file contents, any number of continuation lines may follow which contain "|<another_name>" in order to specify alternative names for the same file (i. e. hard links). Such lines will be interpreted as a continuation of the "P"-attribute.

Symbolic links are currently not supported and will be silently converted into hard-links by the filesystem creation script. But it can be implemented at a later time by using a bit in <mode> to mark a file as symlink. The contents of such special files will then contain the information returned by readlink. The file location script needs to be enhanced in order to resolve such symlinks.

The starting offset is not really relevant for files of size zero, but by convention all such files shall use a starting offset of zero, even though this is not actually part of the file contents area.

There is no requirement to use all available space or regarding the order of file contents; however the contents of each file must be contiguous.

The minimum size possible for a filesystem is 90 Bytes, which contains the mandatory header files and an empty line to terminate the metadata area.

The scan for a file name starts at the beginning of the metadata area; the first matching file will be found.

File names can have any size including the empty string, and they can contain any character except newline.

There is no direct support for subdirectories, but it can be emulated by including "/" as part of the filenames which serves no special purpose in TrivialFS. For example, instead of a subdirector d with two files a and b within it, two filenames d/a and d/b could be used with a similar effect. There is no way to "cd" into a subdirectory, though. The file system generation script will in fact use this approach if subdirectories are present in the input directory.

The metadata area is not designed to be modified after filesystem creation.

All file modifications should therefore be made in-place within the offset and size specified in the directory entry.

If some file's contents have variable size when being updated, the file itself should have been created with the largest possible initial size, and the file contents themselves should be defined in a way to discover the actually used part of the file contents. For instance, the file contents might be prefixed by its payload length and a separator beforr the payload starts.

There are several scripts:

* trivialfs_gen

* trivialfs_volume

* trivialfs_file

* trivialfs_read expects the output of trivialfs_file as standard input, and writes the contents of the described file from the trivial file system to standard output.

* trivialfs_write has the same arguments as trivialfs_read, but accepts up to as many bytes from standard input as the file contents allows, and overwrites the beginning of the described file contents with that.

* trivialfs_explode is the opposite of trivialfs_gen and populates the contents of the current directory with the contents of a TrivialFS, a path to which can be specified either as the only argument or will be read from standard input.
